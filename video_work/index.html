<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				height: 100%;
				font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
				background: #000;
				color: #e5e7eb;
			}

			.app-root {
				display: flex;
				flex-direction: column;
				height: 100%;
				position: relative;
				z-index: 1;
				background: transparent;
			}

			#bg-video {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				object-fit: cover;
				z-index: 0;
			}

			.video-setup {
				position: absolute;
				top: 10px;
				right: 12px;
				background: rgba(15, 23, 42, 0.85);
				border-radius: 8px;
				padding: 6px 8px;
				display: flex;
				align-items: center;
				gap: 6px;
				font-size: 12px;
				z-index: 2;
			}

			.video-setup input {
				width: 80px;
				padding: 2px 4px;
				border-radius: 4px;
				border: 1px solid #4b5563;
				background: rgba(15, 23, 42, 0.9);
				color: #e5e7eb;
			}

			.video-setup button {
				padding: 4px 8px;
				border-radius: 999px;
				border: none;
				font-size: 11px;
				cursor: pointer;
				background: #16a34a;
				color: #ecfdf5;
			}

			header {
				padding: 8px 16px;
				background: #020617;
				border-bottom: 1px solid #1e293b;
				display: flex;
				align-items: center;
				justify-content: space-between;
			}

			header h1 {
				font-size: 16px;
				margin: 0;
			}

			header .meta {
				font-size: 12px;
				color: #9ca3af;
			}

			.main-layout {
				flex: 1;
				display: grid;
				grid-template-columns: minmax(0, 2fr) minmax(0, 1.6fr);
				gap: 0;
				min-height: 0;
			}

			.left-pane {
				display: flex;
				flex-direction: column;
				min-height: 0;
				grid-column: 2;
			}

			/* Path view (地図なしの2Dビュー) */
			#map-container {
				position: relative;
				background: transparent;
				display: flex;
				align-items: stretch;
				justify-content: center;
				flex: 1;
			}

			#path-view {
				width: 100%;
				height: 100%;
				display: block;
				background: transparent;
			}

			/* Right pane */
			.right-pane {
				display: flex;
				flex-direction: column;
				min-height: 0;
				grid-column: 1;
				border-right: 1px solid #111827;
			}

			.controls {
				padding: 8px 12px;
				border-bottom: 1px solid #111827;
				display: flex;
				align-items: center;
				gap: 8px;
				background: #020617;
			}

			.controls button {
				padding: 6px 12px;
				border-radius: 999px;
				border: none;
				font-size: 13px;
				cursor: pointer;
				background: #16a34a;
				color: #ecfdf5;
			}

			.controls button.secondary {
				background: #374151;
				color: #e5e7eb;
			}

			.controls button:disabled {
				opacity: 0.5;
				cursor: default;
			}

			.controls .slider {
				flex: 1;
				display: flex;
				align-items: center;
				gap: 6px;
			}

			.controls input[type="range"] {
				flex: 1;
			}

			.controls .time-label {
				font-size: 11px;
				color: #9ca3af;
				min-width: 130px;
				text-align: right;
			}

			.status-bar {
				padding: 4px 12px;
				font-size: 11px;
				color: #9ca3af;
				display: flex;
				gap: 16px;
			}

			.status-bar span strong {
				color: #e5e7eb;
			}

			.chart-container {
				flex: 0 0 auto;
				padding: 4px 8px 4px;
				display: flex;
				flex-direction: column;
				gap: 4px;
				min-height: 0;
			}

			.chart-header {
				font-size: 12px;
				color: #9ca3af;
				display: flex;
				justify-content: space-between;
				align-items: center;
			}

			.chart-wrapper {
				flex: 0 0 auto;
				background: transparent;
				border-radius: 8px;
				border: 1px solid #111827;
				padding: 6px 8px 10px;
				display: flex;
				flex-direction: column;
				min-height: 0;
			}

			#elevation-chart {
				flex: 0 0 auto;
				height: 220px;
			}

			.chart-caption {
				margin-top: 4px;
				font-size: 11px;
				color: #6b7280;
			}

			.legend {
				display: flex;
				gap: 12px;
				font-size: 11px;
				margin-top: 2px;
			}

			.legend-item {
				display: inline-flex;
				align-items: center;
				gap: 4px;
			}

			.legend-color {
				width: 10px;
				height: 3px;
				border-radius: 999px;
			}

			.legend-color.path-total {
				background: #4b5563;
			}

			.legend-color.path-played {
				background: #f97316;
			}

			.legend-color.chart-elev {
				background: #4b5563;
			}

			.legend-color.chart-cursor {
				background: #fbbf24;
			}

			.error-banner {
				padding: 6px 10px;
				font-size: 12px;
				background: rgba(127, 29, 29, 0.6);
				border-bottom: 1px solid #7f1d1d;
				color: #fecaca;
			}

			@media (max-width: 900px) {
				.main-layout {
					grid-template-columns: minmax(0, 1fr);
					grid-template-rows: minmax(0, 1.2fr) minmax(0, 1fr);
				}

				.left-pane {
					border-right: none;
					border-bottom: 1px solid #111827;
				}
			}
		</style>
	</head>
	<body>
		<video id="bg-video" src="363.mp4" muted playsinline preload="metadata"></video>
		<div class="app-root">
			<header>
				<h1>区間移動 × 標高 × 時間 可視化</h1>
				<div class="meta">coords_segment / elevation_segment / segment_timestamps を連動表示</div>
			</header>

			<div id="error" class="error-banner" style="display: none"></div>

			<div class="main-layout">
				<div id="video-time-setup" class="video-setup">
					<span>動画開始位置</span>
					<input id="video-start-input" type="text" placeholder="mm:ss または 秒" />
					<button id="video-start-apply">OK</button>
				</div>

				<div class="left-pane">
					<div class="chart-container">
						<div class="chart-header">
							<span>標高プロファイル</span>
							<span id="chart-range" style="font-size: 11px; color: #6b7280"></span>
						</div>

						<div class="chart-wrapper">
							<svg id="elevation-chart" viewBox="0 0 800 220" preserveAspectRatio="none"></svg>
							<div class="legend">
								<div class="legend-item">
									<span class="legend-color path-total"></span>
									<span>全区間（地図）</span>
								</div>
								<div class="legend-item">
									<span class="legend-color path-played"></span>
									<span>再生済み区間（地図）</span>
								</div>
								<div class="legend-item">
									<span class="legend-color chart-elev"></span>
									<span>標高 (m)</span>
								</div>
								<div class="legend-item">
									<span class="legend-color chart-cursor"></span>
									<span>現在位置</span>
								</div>
							</div>
							<div class="chart-caption">スライダー or 再生ボタンで、時間に沿って位置と標高が同期して動きます。</div>
						</div>
					</div>

					<div id="map-container">
						<svg id="path-view" viewBox="0 0 800 600" preserveAspectRatio="xMidYMid meet"></svg>
					</div>
				</div>

				<div class="right-pane">
					<div class="controls">
						<button id="play-btn">▶ 再生</button>
						<button id="pause-btn" class="secondary" disabled>⏸ 一時停止</button>

						<div class="slider">
							<input id="index-slider" type="range" min="0" max="0" value="0" step="1" />
						</div>

						<div class="time-label">
							<div id="playback-elapsed">00:00 / 00:00</div>
							<div id="time-label-abs">--:--:--</div>
						</div>
					</div>

					<div class="status-bar">
						<span>Index: <strong id="status-index">-</strong></span>
						<span>標高: <strong id="status-elev">- m</strong></span>
						<span>座標: <strong id="status-latlon">-</strong></span>
					</div>
				</div>
			</div>
		</div>

		<script>
			// ===============================
			// 設定（必要であればここだけ編集）
			// ===============================

			// データファイルのパス
			const COORDS_URL = "coords_segment_list.json";
			const ELEVATION_URL = "elevation_segment_list.json";
			const SEGMENT_TS_URL = "segment_points_with_timestamps.json";

			// 再生スピード倍率
			// 1 = 現実世界と同じ速度（timestamp の秒数と画面上の秒が一致）
			// >1 = 早送り, <1 = スロー
			const PLAYBACK_SPEED = 1;

			// どんなに間隔が短い点でも、最低このミリ秒で次の点へ進む
			const MIN_FRAME_DURATION_MS = 80;

			// マップ表示に使うスタイル
			const MAP_STYLE = {
				basePathColor: "#4b5563",
				basePathWeight: 4,
				playedPathColor: "#f97316",
				playedPathWeight: 5,
				currentMarkerColor: "#facc15",
			};

			// ===============================
			// ユーティリティ
			// ===============================

			function showError(message) {
				const el = document.getElementById("error");
				el.textContent = message;
				el.style.display = "block";
			}

			function formatTimeLabel(date) {
				if (!date) return "--:--:--";
				const y = date.getFullYear();
				const m = String(date.getMonth() + 1).padStart(2, "0");
				const d = String(date.getDate()).padStart(2, "0");
				const hh = String(date.getHours()).padStart(2, "0");
				const mm = String(date.getMinutes()).padStart(2, "0");
				const ss = String(date.getSeconds()).padStart(2, "0");
				return `${y}-${m}-${d} ${hh}:${mm}:${ss}`;
			}

			function lerp(a, b, t) {
				return a + (b - a) * t;
			}

			function parseTimeToSeconds(input) {
				if (!input) return NaN;
				const trimmed = input.trim();
				if (!trimmed) return NaN;

				// mm:ss or hh:mm:ss 形式
				if (trimmed.includes(":")) {
					const parts = trimmed.split(":").map((p) => Number(p));
					if (parts.some((n) => Number.isNaN(n))) return NaN;
					let seconds = 0;
					if (parts.length === 2) {
						const [m, s] = parts;
						seconds = m * 60 + s;
					} else if (parts.length === 3) {
						const [h, m, s] = parts;
						seconds = h * 3600 + m * 60 + s;
					} else {
						return NaN;
					}
					return seconds;
				}

				// 生の秒数
				const asNumber = Number(trimmed);
				return Number.isNaN(asNumber) ? NaN : asNumber;
			}

			// ===============================
			// メインロジック
			// ===============================

			async function loadJson(url) {
				const res = await fetch(url);
				if (!res.ok) {
					throw new Error(`${url} の読み込みに失敗しました (${res.status})`);
				}
				return res.json();
			}

			async function init() {
				try {
					const [coords, elevations, segmentTs] = await Promise.all([
						loadJson(COORDS_URL),
						loadJson(ELEVATION_URL),
						loadJson(SEGMENT_TS_URL),
					]);

					if (!Array.isArray(coords) || !Array.isArray(elevations) || !Array.isArray(segmentTs)) {
						showError("JSON フォーマットが配列ではありません。");
						return;
					}

					const length = Math.min(coords.length, elevations.length, segmentTs.length);
					if (length === 0) {
						showError("有効なデータがありません。");
						return;
					}

					if (coords.length !== elevations.length || coords.length !== segmentTs.length) {
						showError(
							`配列長が一致しません: coords=${coords.length}, elevation=${elevations.length}, ts=${segmentTs.length}。 ` +
								`最小の ${length} 個のみを使用します。`
						);
					}

					const slicedCoords = coords.slice(0, length);
					const slicedElev = elevations.slice(0, length);
					const slicedTs = segmentTs.slice(0, length);

					// timestamp を Date に変換しつつ、壊れているものは除外したうえで
					// 時系列順にソートして UI に渡す
					const combined = [];
					for (let i = 0; i < length; i++) {
						const tsStr = slicedTs[i].timestamp;
						const tsDate = new Date(tsStr);
						if (!tsStr || Number.isNaN(tsDate.getTime())) {
							console.warn("無効な timestamp をスキップします", slicedTs[i]);
							continue;
						}
						combined.push({
							coord: slicedCoords[i],
							elev: slicedElev[i],
							ts: tsDate,
						});
					}

					if (combined.length === 0) {
						showError("有効な timestamp を含むデータがありません。");
						return;
					}

					combined.sort((a, b) => a.ts - b.ts);

					const sortedCoords = combined.map((c) => c.coord);
					const sortedElev = combined.map((c) => c.elev);
					const tsDates = combined.map((c) => c.ts);

					setupUI(sortedCoords, sortedElev, tsDates);
				} catch (err) {
					console.error(err);
					showError(err.message || String(err));
				}
			}

			function setupUI(coords, elevations, tsDates) {
				const n = coords.length;

				// DOM 取得
				const playBtn = document.getElementById("play-btn");
				const pauseBtn = document.getElementById("pause-btn");
				const slider = document.getElementById("index-slider");
				const timeLabelAbs = document.getElementById("time-label-abs");
				const playbackElapsed = document.getElementById("playback-elapsed");
				const bgVideo = document.getElementById("bg-video");
				const videoTimeSetup = document.getElementById("video-time-setup");
				const videoStartInput = document.getElementById("video-start-input");
				const videoStartApply = document.getElementById("video-start-apply");
				let videoStartConfigured = false;
				let videoStartSeconds = 0;

				const statusIndex = document.getElementById("status-index");
				const statusElev = document.getElementById("status-elev");
				const statusLatLon = document.getElementById("status-latlon");
				const chartRange = document.getElementById("chart-range");

				// 初期状態では動画は停止・再生ボタンは無効
				if (bgVideo) {
					try {
						bgVideo.pause();
						bgVideo.currentTime = 0;
					} catch (e) {
						console.warn("背景動画の初期化に失敗しました", e);
					}
				}
				playBtn.disabled = true;
				pauseBtn.disabled = true;

				slider.max = String(n - 1);
				slider.value = "0";

				// 時間レンジ表示（データの起点と終点の timestamp 差）
				const start = tsDates[0];
				const end = tsDates[tsDates.length - 1];
				const minMillis = start.getTime();
				const maxMillis = end.getTime();
				const elapsedSec = (maxMillis - minMillis) / 1000;
				const mm = Math.floor(elapsedSec / 60);
				const ss = Math.round(elapsedSec % 60)
					.toString()
					.padStart(2, "0");
				chartRange.textContent = `${formatTimeLabel(start)} → ${formatTimeLabel(end)} (約 ${mm}:${ss} 経過)`;

				function formatMmSs(totalSec) {
					const s = Math.max(0, Math.floor(totalSec));
					const m = Math.floor(s / 60);
					const rem = String(s % 60).padStart(2, "0");
					return `${m}:${rem}`;
				}

				function updatePlaybackElapsed(currentMs) {
					const clamped = Math.max(minMillis, Math.min(maxMillis, currentMs));
					const elapsedNow = (clamped - minMillis) / 1000;
					playbackElapsed.textContent = `${formatMmSs(elapsedNow)} / ${formatMmSs(elapsedSec)}`;
				}

				// 動画開始位置入力の適用処理
				function applyVideoStart() {
					if (!bgVideo || !videoStartInput) return;
					const raw = videoStartInput.value;
					const sec = parseTimeToSeconds(raw);
					if (Number.isNaN(sec) || sec < 0) {
						alert("時間は mm:ss または 秒数 で入力してください。");
						return;
					}
					try {
						videoStartSeconds = sec;
						const seek = () => {
							// duration が取得できている場合は範囲内にクランプ
							let target = videoStartSeconds;
							if (Number.isFinite(bgVideo.duration) && bgVideo.duration > 0) {
								const maxSeek = Math.max(0, bgVideo.duration - 0.1);
								target = Math.min(target, maxSeek);
							}
							bgVideo.currentTime = target;
							bgVideo.pause();
							videoStartConfigured = true;
							playBtn.disabled = false;
							pauseBtn.disabled = true;
							if (videoTimeSetup) {
								videoTimeSetup.style.display = "none";
							}
						};

						if (bgVideo.readyState >= 1) {
							seek();
						} else {
							bgVideo.addEventListener(
								"loadedmetadata",
								() => {
									seek();
								},
								{ once: true }
							);
							bgVideo.load();
						}
					} catch (e) {
						console.warn("動画シークに失敗しました", e);
					}
				}

				if (videoStartApply) {
					videoStartApply.addEventListener("click", applyVideoStart);
				}
				if (videoStartInput) {
					videoStartInput.addEventListener("keydown", (ev) => {
						if (ev.key === "Enter") {
							applyVideoStart();
						}
					});
				}

				// 2D パスビュー初期化（緯度経度を平面に投影）
				const pathSvg = document.getElementById("path-view");
				const pathWidth = 800;
				const pathHeight = 600;
				const pathMargin = 30;
				pathSvg.setAttribute("viewBox", `0 0 ${pathWidth} ${pathHeight}`);

				const lats = coords.map((c) => c[0]);
				const lons = coords.map((c) => c[1]);
				const minLat = Math.min(...lats);
				const maxLat = Math.max(...lats);
				const minLon = Math.min(...lons);
				const maxLon = Math.max(...lons);

				function projectCoord(coord) {
					const [lat, lon] = coord;
					const lonSpan = maxLon - minLon || 1;
					const latSpan = maxLat - minLat || 1;
					const x =
						((lon - minLon) / lonSpan) * (pathWidth - pathMargin * 2) + pathMargin;
					const y =
						((maxLat - lat) / latSpan) * (pathHeight - pathMargin * 2) + pathMargin;
					return { x, y };
				}

				const projectedPoints = coords.map(projectCoord);

				// 背景
				const pathBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
				pathBg.setAttribute("x", "0");
				pathBg.setAttribute("y", "0");
				pathBg.setAttribute("width", String(pathWidth));
				pathBg.setAttribute("height", String(pathHeight));
				pathBg.setAttribute("fill", "none");
				pathSvg.appendChild(pathBg);

				// 全区間パス
				const basePolyline = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"polyline"
				);
				basePolyline.setAttribute(
					"points",
					projectedPoints.map((p) => `${p.x},${p.y}`).join(" ")
				);
				basePolyline.setAttribute("fill", "none");
				basePolyline.setAttribute("stroke", MAP_STYLE.basePathColor);
				basePolyline.setAttribute("stroke-width", String(MAP_STYLE.basePathWeight));
				basePolyline.setAttribute("stroke-linecap", "round");
				basePolyline.setAttribute("stroke-linejoin", "round");
				basePolyline.setAttribute("opacity", "0.8");
				pathSvg.appendChild(basePolyline);

				// 再生済みパス
				const playedPolyline = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"polyline"
				);
				playedPolyline.setAttribute("fill", "none");
				playedPolyline.setAttribute("stroke", MAP_STYLE.playedPathColor);
				playedPolyline.setAttribute(
					"stroke-width",
					String(MAP_STYLE.playedPathWeight)
				);
				playedPolyline.setAttribute("stroke-linecap", "round");
				playedPolyline.setAttribute("stroke-linejoin", "round");
				playedPolyline.setAttribute("opacity", "0.95");
				pathSvg.appendChild(playedPolyline);

				// 現在位置マーカー
				const currentMarker = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"circle"
				);
				currentMarker.setAttribute("r", "5");
				currentMarker.setAttribute("stroke", "#111827");
				currentMarker.setAttribute("stroke-width", "2");
				currentMarker.setAttribute("fill", MAP_STYLE.currentMarkerColor);
				pathSvg.appendChild(currentMarker);

				// 標高チャート初期化
				const svg = document.getElementById("elevation-chart");
				const width = 800;
				const height = 220;
				const paddingLeft = 24;
				const paddingRight = 6;
				const paddingTop = 10;
				const paddingBottom = 18;

				const chartWidth = width - paddingLeft - paddingRight;
				const chartHeight = height - paddingTop - paddingBottom;
				const elevPoints = [];

				const minElev = Math.min(...elevations);
				const maxElev = Math.max(...elevations);

				const bg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
				bg.setAttribute("x", "0");
				bg.setAttribute("y", "0");
				bg.setAttribute("width", String(width));
				bg.setAttribute("height", String(height));
				bg.setAttribute("fill", "none");
				svg.appendChild(bg);

				// 軸っぽいライン
				const axis = document.createElementNS("http://www.w3.org/2000/svg", "line");
				axis.setAttribute("x1", paddingLeft);
				axis.setAttribute("x2", width - paddingRight);
				axis.setAttribute("y1", height - paddingBottom);
				axis.setAttribute("y2", height - paddingBottom);
				axis.setAttribute("stroke", "#4b5563");
				axis.setAttribute("stroke-width", "1");
				axis.setAttribute("stroke-linecap", "round");
				svg.appendChild(axis);

				// 標高線のパス（ベース）
				const basePath = document.createElementNS("http://www.w3.org/2000/svg", "path");
				const dParts = [];
				for (let i = 0; i < n; i++) {
					const x = paddingLeft + (i / Math.max(1, n - 1)) * chartWidth;
					const t = (elevations[i] - minElev) / Math.max(1, maxElev - minElev);
					const y = paddingTop + (1 - t) * chartHeight;
					dParts.push(`${i === 0 ? "M" : "L"}${x},${y}`);
					elevPoints.push({ x, y });
				}
				basePath.setAttribute("d", dParts.join(" "));
				basePath.setAttribute("fill", "none");
				basePath.setAttribute("stroke", "#4b5563");
				basePath.setAttribute("stroke-width", "2");
				svg.appendChild(basePath);

				// 再生済み部分のパス（オレンジ）
				const playedElevPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
				playedElevPath.setAttribute("fill", "none");
				playedElevPath.setAttribute("stroke", "#f97316");
				playedElevPath.setAttribute("stroke-width", "2");
				svg.appendChild(playedElevPath);

				// 現在位置カーソル
				const cursor = document.createElementNS("http://www.w3.org/2000/svg", "line");
				cursor.setAttribute("y1", paddingTop - 2);
				cursor.setAttribute("y2", height - paddingBottom + 2);
				cursor.setAttribute("stroke", "#fbbf24");
				cursor.setAttribute("stroke-width", "2");
				cursor.setAttribute("stroke-linecap", "round");
				svg.appendChild(cursor);

				// 標高範囲のラベル
				const elevMinText = document.createElementNS("http://www.w3.org/2000/svg", "text");
				elevMinText.setAttribute("x", paddingLeft);
				elevMinText.setAttribute("y", height - 2);
				elevMinText.setAttribute("fill", "#6b7280");
				elevMinText.setAttribute("font-size", "10");
				elevMinText.textContent = `${minElev.toFixed(0)} m`;
				svg.appendChild(elevMinText);

				const elevMaxText = document.createElementNS("http://www.w3.org/2000/svg", "text");
				elevMaxText.setAttribute("x", paddingLeft);
				elevMaxText.setAttribute("y", paddingTop + 10);
				elevMaxText.setAttribute("fill", "#9ca3af");
				elevMaxText.setAttribute("font-size", "10");
				elevMaxText.textContent = `${maxElev.toFixed(0)} m`;
				svg.appendChild(elevMaxText);

				// インデックス変更処理 & 再生状態
				let currentIndex = 0;
				let playing = false;
				let rafId = null;
				let playStartRealMs = 0; // 再生開始時刻（ブラウザ時間）
				let playStartDataMs = minMillis; // 再生開始時のデータ時間（timestamp 基準）

				function setIndex(i, options) {
					const { syncVideo = false } = options || {};
					i = Math.max(0, Math.min(n - 1, i));
					currentIndex = i;
					slider.value = String(i);

					// 2D パスビューの現在位置更新
					const pt = projectedPoints[i];
					currentMarker.setAttribute("cx", String(pt.x));
					currentMarker.setAttribute("cy", String(pt.y));

					// 再生済みパス更新
					const playedPoints = projectedPoints
						.slice(0, i + 1)
						.map((p) => `${p.x},${p.y}`)
						.join(" ");
					playedPolyline.setAttribute("points", playedPoints);

					// 標高カーソル & 再生済み標高ライン更新
					const x = paddingLeft + (i / Math.max(1, n - 1)) * chartWidth;
					cursor.setAttribute("x1", x);
					cursor.setAttribute("x2", x);

					const elevDParts = [];
					for (let j = 0; j <= i; j++) {
						const pt = elevPoints[j];
						if (!pt) continue;
						elevDParts.push(`${j === 0 ? "M" : "L"}${pt.x},${pt.y}`);
					}
					playedElevPath.setAttribute("d", elevDParts.join(" "));

					const elev = elevations[i];
					const ts = tsDates[i];
					const coord = coords[i];

					statusIndex.textContent = `${i + 1} / ${n}`;
					statusElev.textContent = `${elev.toFixed(1)} m`;
					statusLatLon.textContent = `${coord[0].toFixed(6)}, ${coord[1].toFixed(6)}`;
					timeLabelAbs.textContent = formatTimeLabel(ts);
					updatePlaybackElapsed(ts.getTime());

					// ユーザー操作によるシーク時は動画の位置も同期
					if (syncVideo && bgVideo && videoStartConfigured) {
						try {
							const elapsedFromStartSec = (ts.getTime() - minMillis) / 1000;
							let target = videoStartSeconds + elapsedFromStartSec;
							if (Number.isFinite(bgVideo.duration) && bgVideo.duration > 0) {
								const maxSeek = Math.max(0, bgVideo.duration - 0.1);
								target = Math.min(Math.max(0, target), maxSeek);
							}
							bgVideo.currentTime = target;
						} catch (e) {
							console.warn("動画シーク同期に失敗しました", e);
						}
					}
				}

				function stopAnimation() {
					if (rafId != null) {
						cancelAnimationFrame(rafId);
						rafId = null;
					}
				}

				function tick() {
					if (!playing) return;

					const now = performance.now();
					const elapsedRealSec = (now - playStartRealMs) / 1000;
					// PLAYBACK_SPEED 倍速でデータ時間を進める
					const targetDataMs = Math.min(
						maxMillis,
						playStartDataMs + elapsedRealSec * PLAYBACK_SPEED * 1000
					);

					// 現在のデータ時間を超えた index まで進める
					let advanced = false;
					while (
						currentIndex < n - 1 &&
						tsDates[currentIndex + 1].getTime() <= targetDataMs
					) {
						currentIndex += 1;
						setIndex(currentIndex);
						advanced = true;
					}

					// 再生中は常に「今の仮想時間」に合わせて時計表示を更新
					const virtualDate = new Date(targetDataMs);
					timeLabelAbs.textContent = formatTimeLabel(virtualDate);
					updatePlaybackElapsed(targetDataMs);

					// 終端まで到達したら停止
					if (targetDataMs >= maxMillis || currentIndex >= n - 1) {
						playing = false;
						playBtn.disabled = false;
						pauseBtn.disabled = true;
						if (bgVideo && !bgVideo.paused) {
							bgVideo.pause();
						}
						stopAnimation();
						return;
					}

					rafId = requestAnimationFrame(tick);
				}

				function handlePlay() {
					if (playing) return;
					if (!videoStartConfigured) return;
					// 終端にいたら先頭から
					if (currentIndex >= n - 1) {
						setIndex(0);
					}
					playing = true;
					playBtn.disabled = true;
					pauseBtn.disabled = false;
					if (bgVideo) {
						try {
							// 再生開始前に設定された開始秒にシーク
							if (!Number.isNaN(videoStartSeconds) && videoStartSeconds >= 0) {
								bgVideo.currentTime = videoStartSeconds;
							}
							bgVideo.muted = true;
							bgVideo.play();
						} catch (e) {
							console.warn("背景動画の再生に失敗しました", e);
						}
					}
					playStartRealMs = performance.now();
					playStartDataMs = tsDates[currentIndex].getTime();
					rafId = requestAnimationFrame(tick);
				}

				function handlePause() {
					playing = false;
					stopAnimation();
					playBtn.disabled = false;
					pauseBtn.disabled = true;
					if (bgVideo && !bgVideo.paused) {
						bgVideo.pause();
					}
				}

				playBtn.addEventListener("click", handlePlay);
				pauseBtn.addEventListener("click", handlePause);

					slider.addEventListener("input", () => {
					// スライダーを動かしたら一旦停止
					playing = false;
					stopAnimation();
					playBtn.disabled = false;
					pauseBtn.disabled = true;

						const idx = Number(slider.value) || 0;
						// スライダーによるシークでは動画も同期させる
						setIndex(idx, { syncVideo: true });
				});

					// 初期表示（動画同期は不要）
					setIndex(0);
			}

			window.addEventListener("load", init);
		</script>
	</body>
	</html>

