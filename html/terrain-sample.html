<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Terrain from Grid</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
          "OrbitControls": "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <script type="module">
      // Three.jsとOrbitControlsをモジュールとしてインポート
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js";

      async function loadTerrainData() {
        const response = await fetch("elevation_grid.json");
        const data = await response.json();
        return data;
      }

      // シーン、カメラ、レンダラーの作成
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // カメラ位置
      camera.up.set(0, 0, 1);
      camera.position.set(0, 0, 400); // Z軸を真上から見る。
      camera.lookAt(0, 0, 0); // 原点を見る

      // グリッドの座標と高さデータ（多次元配列: x, y, z）
      const terrainData = await loadTerrainData();

      const baseLat = terrainData[0][0][0]; // 基準の緯度
      const baseLon = terrainData[0][0][1]; // 基準の経度
      const baseElev = terrainData[0][0][2]; // 基準の標高

      // gridDataを基に各座標を基準からの相対的な座標に変換し、Vector3オブジェクトを作成
      const gridData = terrainData.map((data) => {
        // console.log(data);
        return data.map((d) => {
          // console.log(d);
          const lat = d[0]; // 緯度
          const lon = d[1]; // 経度
          const elev = d[2]; // 標高

          // 基準座標に対する相対座標を計算
          const x = (lon - baseLon) / 10; // 経度の差をX座標として正規化
          const y = (lat - baseLat) / 10; // 緯度の差をY座標として正規化
          const z = (elev - baseElev) / 6; // 標高の差をZ座標として正規化
          console.log([x, y, z]);

          return [x, y, z];
        });
      });

      // ジオメトリの作成
      const geometry = new THREE.BufferGeometry();
      const vertices = [];

      // 頂点データを取得して三角形を作成
      for (let y = 0; y < gridData.length - 1; y++) {
        for (let x = 0; x < gridData[y].length - 1; x++) {
          // 2つの三角形で1つの四角形を構成
          const v0 = gridData[y][x];
          const v1 = gridData[y + 1][x];
          const v2 = gridData[y][x + 1];
          const v3 = gridData[y + 1][x + 1];

          // 1つ目の三角形
          vertices.push(...v0);
          vertices.push(...v1);
          vertices.push(...v2);

          // 2つ目の三角形
          vertices.push(...v2);
          vertices.push(...v1);
          vertices.push(...v3);
        }
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(new Float32Array(vertices), 3)
      );

      // 中心座標を計算 (X, Y, Zの範囲を取得して中心を計算)
      geometry.computeBoundingBox();
      const boundingBox = geometry.boundingBox;
      const centerX = (boundingBox.max.x + boundingBox.min.x) / 2;
      const centerY = (boundingBox.max.y + boundingBox.min.y) / 2;
      const centerZ = (boundingBox.max.z + boundingBox.min.z) / 2;

      // ジオメトリの中心をシーンの中心に移動
      geometry.translate(-centerX, -centerY, -centerZ);

      // マテリアルを作成
      const material = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        color: 0x00ff00,
        flatShading: true,
      });

      // メッシュを作成し、シーンに追加
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true; // 影を落とす
      scene.add(mesh);

      // // 影を受ける平面
      const planeGeometry = new THREE.PlaneGeometry(10, 10);
      const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.5 }); // 影が見えるように設定
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.position.z = -0.01; // ほんの少し下に配置して影を受ける
      plane.rotation.x = -Math.PI / 2; // Z軸を上にするために平面を回転
      plane.receiveShadow = true; // 影を受ける
      scene.add(plane);

      // ライトの追加（影のための光源）
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, -5, 5); // ライトの位置
      directionalLight.castShadow = true; // ライトに影を有効化
      scene.add(directionalLight);

      // OrbitControlsを追加して、カメラをマウス操作で回転させる
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // 慣性効果
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.maxPolarAngle = Math.PI / 2; // 上向きすぎるのを防ぐ

      // レンダリングの設定
      function animate() {
        requestAnimationFrame(animate);
        controls.update(); // OrbitControlsを更新
        renderer.render(scene, camera);
      }
      animate();

      // ウィンドウのリサイズに対応
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
