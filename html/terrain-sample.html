<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Terrain from Grid</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
          "OrbitControls": "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <script type="module">
      // Three.jsとOrbitControlsをモジュールとしてインポート
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js";

      // シーン、カメラ、レンダラーの作成
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // カメラ位置
      camera.up.set(0, 0, 1);
      camera.position.set(0, 0, 10); // Z軸を真上から見る。
      camera.lookAt(0, 0, 0); // 原点を見る

      // グリッドの座標と高さデータ（多次元配列: x, y, z）
      const gridData = [
        [
          [0, 0, 0],
          [1, 0, 0],
          [2, 0, 0],
          [3, 0, 0],
          [4, 0, 0],
          [5, 0, 0],
        ],
        [
          [0, 1, 0],
          [1, 1, 1],
          [2, 1, 0],
          [3, 1, 1],
          [4, 1, 0],
          [5, 1, 0],
        ],
        [
          [0, 2, 0],
          [1, 2, 0],
          [2, 2, 1],
          [3, 2, 0],
          [4, 2, 1],
          [5, 2, 0],
        ],
        [
          [0, 3, 0],
          [1, 3, 1],
          [2, 3, 0],
          [3, 3, 1],
          [4, 3, 0],
          [5, 3, 0],
        ],
        [
          [0, 4, 0],
          [1, 4, 0],
          [2, 4, 1],
          [3, 4, 0],
          [4, 4, 1],
          [5, 4, 0],
        ],
        [
          [0, 5, 0],
          [1, 5, 0],
          [2, 5, 0],
          [3, 5, 0],
          [4, 5, 0],
          [5, 5, 0],
        ],
      ];

      // ジオメトリの作成
      const geometry = new THREE.BufferGeometry();
      const vertices = [];

      // 頂点データを取得して三角形を作成
      for (let y = 0; y < gridData.length - 1; y++) {
        for (let x = 0; x < gridData[y].length - 1; x++) {
          // 2つの三角形で1つの四角形を構成
          const v0 = gridData[y][x];
          const v1 = gridData[y + 1][x];
          const v2 = gridData[y][x + 1];
          const v3 = gridData[y + 1][x + 1];

          // 1つ目の三角形
          vertices.push(...v0);
          vertices.push(...v1);
          vertices.push(...v2);

          // 2つ目の三角形
          vertices.push(...v2);
          vertices.push(...v1);
          vertices.push(...v3);
        }
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(new Float32Array(vertices), 3)
      );

      // マテリアルを作成
      const material = new THREE.MeshPhongMaterial({
        side: THREE.DoubleSide,
        color: 0x00ff00,
        flatShading: true,
      });

      // メッシュを作成し、シーンに追加
      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true; // 影を落とす
      scene.add(mesh);

      // // 影を受ける平面
      const planeGeometry = new THREE.PlaneGeometry(10, 10);
      const planeMaterial = new THREE.ShadowMaterial({ opacity: 0.5 }); // 影が見えるように設定
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      plane.position.z = -0.01; // ほんの少し下に配置して影を受ける
      plane.rotation.x = -Math.PI / 2; // Z軸を上にするために平面を回転
      plane.receiveShadow = true; // 影を受ける
      scene.add(plane);

      // ライトの追加（影のための光源）
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, -5, 5); // ライトの位置
      directionalLight.castShadow = true; // ライトに影を有効化
      scene.add(directionalLight);

      // OrbitControlsを追加して、カメラをマウス操作で回転させる
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; // 慣性効果
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.maxPolarAngle = Math.PI / 2; // 上向きすぎるのを防ぐ

      // レンダリングの設定
      function animate() {
        requestAnimationFrame(animate);
        controls.update(); // OrbitControlsを更新
        renderer.render(scene, camera);
      }
      animate();

      // ウィンドウのリサイズに対応
      window.addEventListener("resize", () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
