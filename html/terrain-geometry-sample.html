<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Terrain from Grid</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
          "OrbitControls": "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
    <script type="module">
      // Three.jsとOrbitControlsをモジュールとしてインポート
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js";

      const main = async () => {
        async function loadJson(path) {
          const response = await fetch(path);
          const data = await response.json();
          return data;
        }

        const generateRenderer = (width, height) => {
          const renderer = new THREE.WebGLRenderer();
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);
          return renderer;
        };

        const generateScene = () => {
          return new THREE.Scene();
        };

        const generateCamera = (renderer, width, height) => {
          const camera = new THREE.PerspectiveCamera(
            75,
            width / height,
            0.1,
            1000
          );
          // カメラ位置
          camera.up.set(0, 0, 1);
          camera.position.set(0, 0, 400); // Z軸を真上から見る。
          camera.lookAt(0, 0, 0); // 原点を見る

          // OrbitControlsを追加して、カメラをマウス操作で回転させる
          const cameraControls = new OrbitControls(camera, renderer.domElement);
          cameraControls.enableDamping = true; // 慣性効果
          cameraControls.dampingFactor = 0.05;
          cameraControls.screenSpacePanning = false;
          cameraControls.maxPolarAngle = Math.PI / 2; // 上向きすぎるのを防ぐ

          return { camera, cameraControls };
        };

        const generateRoadMesh = (
          elevations,
          coordinates,
          baseX,
          baseY,
          baseZ
        ) => {
          const points = coordinates.map((coord, index) => {
            const x = (coord[1] - baseY) / 10; // coordinates[0]のX座標を基準に
            const y = (coord[0] - baseX) / 10; // coordinates[0]のY座標を基準に
            const z = (elevations[index] - baseZ) / 6;
            return new THREE.Vector3(x, y, z);
          });

          // 頂点を結ぶ一本の線を作成
          const geometry = new THREE.BufferGeometry().setFromPoints(points);

          // マテリアルを作成
          const material = new THREE.LineBasicMaterial({
            color: 0xff0000, // 赤色の線
          });

          // ラインを作成
          const roadMeth = new THREE.Line(geometry, material);

          // 最高点からZ軸0までの線を描画
          const maxZIndex = elevations.indexOf(Math.max(...elevations));
          const maxPoint = points[maxZIndex];

          const addVerticalLineToZero = (point, color) => {
            const material = new THREE.LineBasicMaterial({ color: color });
            const linePoints = [];
            linePoints.push(new THREE.Vector3(point.x, point.y, point.z));
            linePoints.push(new THREE.Vector3(point.x, point.y, 0));
            linePoints.push(new THREE.Vector3(0, 0, 0));

            const lineGeometry = new THREE.BufferGeometry().setFromPoints(
              linePoints
            );
            const verticalLineMeth = new THREE.Line(lineGeometry, material);
            return verticalLineMeth;
          };

          const verticalLineMeth = addVerticalLineToZero(maxPoint, 0x00ffff); // 青色で最高点からZ軸0までの線

          return { roadMeth, verticalLineMeth };
        };

        const generateTerrainMesh = async (
          terrainData,
          baseLat,
          baseLon,
          baseElev
        ) => {
          // // グリッドの座標と高さデータ（多次元配列: x, y, z）
          // const baseLat = terrainData[0][0][0]; // 基準の緯度
          // const baseLon = terrainData[0][0][1]; // 基準の経度
          // const baseElev = terrainData[0][0][2]; // 基準の標高

          // gridDataを基に各座標を基準からの相対的な座標に変換し、Vector3オブジェクトを作成
          const gridData = terrainData.map((data) => {
            // console.log(data);
            return data.map((d) => {
              // console.log(d);
              const lat = d[0]; // 緯度
              const lon = d[1]; // 経度
              const elev = d[2]; // 標高

              // 基準座標に対する相対座標を計算
              const x = (lon - baseLon) / 10; // 経度の差をX座標として正規化
              const y = (lat - baseLat) / 10; // 緯度の差をY座標として正規化
              const z = (elev - baseElev) / 6; // 標高の差をZ座標として正規化

              return [x, y, z];
            });
          });
          // ジオメトリの作成
          const geometry = new THREE.BufferGeometry();
          const vertices = [];

          // 頂点データを取得して三角形を作成
          for (let y = 0; y < gridData.length - 1; y++) {
            for (let x = 0; x < gridData[y].length - 1; x++) {
              // 2つの三角形で1つの四角形を構成
              const v0 = gridData[y][x];
              const v1 = gridData[y + 1][x];
              const v2 = gridData[y][x + 1];
              const v3 = gridData[y + 1][x + 1];

              // 1つ目の三角形
              vertices.push(...v0);
              vertices.push(...v1);
              vertices.push(...v2);

              // 2つ目の三角形
              vertices.push(...v2);
              vertices.push(...v1);
              vertices.push(...v3);
            }
          }

          geometry.setAttribute(
            "position",
            new THREE.BufferAttribute(new Float32Array(vertices), 3)
          );

          // 中心座標を計算 (X, Y, Zの範囲を取得して中心を計算)
          geometry.computeBoundingBox();
          const boundingBox = geometry.boundingBox;
          const centerX = (boundingBox.max.x + boundingBox.min.x) / 2;
          const centerY = (boundingBox.max.y + boundingBox.min.y) / 2;
          const centerZ = (boundingBox.max.z + boundingBox.min.z) / 2;

          // // ★こいつがずれの原因か?
          // // ジオメトリの中心をシーンの中心に移動
          // geometry.translate(-centerX, -centerY, -centerZ);

          // 面の表面を表すベクトルを自動計算
          geometry.computeVertexNormals(); // 法線を自動計算

          // マテリアルを作成
          const material = new THREE.MeshStandardMaterial({
            // side: THREE.DoubleSide,
            color: 0x00ff00, // 緑色
            roughness: 0.8, // ラフネス (0: つるつる, 1: ザラザラ)
            metalness: 0.5, // 金属度 (0: 非金属, 1: 金属)
            latShading: false, // スムースシェーディングを有効にする
          });

          // メッシュを作成し、シーンに追加
          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true; // 影を落とす

          return mesh;
        };

        const generateAmbientLight = () => {
          // 環境光(全体を光らせる)を追加
          const ambientLight = new THREE.AmbientLight(0xffffff, 0);
          return ambientLight;
        };

        const generateDirectionalLight = () => {
          // ライトの追加（影のための光源）
          const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
          directionalLight.position.set(10, 10, 20); // ライトの位置
          directionalLight.castShadow = true; // ライトに影を有効化
          // directionalLight.shadow.mapSize.width = 4096; // 高解像度に設定
          // directionalLight.shadow.mapSize.height = 4096;

          // DirectionalLightHelperを追加して光源の位置と方向を視覚化
          const directionalLightHelper = new THREE.DirectionalLightHelper(
            directionalLight,
            5
          );

          // カメラヘルパーを追加して影の影響範囲を視覚化
          const shadowCameraHelper = new THREE.CameraHelper(
            directionalLight.shadow.camera
          );
          return {
            directionalLight,
            directionalLightHelper,
            shadowCameraHelper,
          };
        };

        // シーン、カメラ、レンダラーの作成
        const renderer = generateRenderer(
          window.innerWidth,
          window.innerHeight
        );
        const scene = generateScene();
        const { camera, cameraControls } = generateCamera(
          renderer,
          innerWidth,
          window.innerHeight
        );

        // 地形ロード
        const terrainData = await loadJson("elevation_grid.json");

        // 基準の緯度、経度、標高を取得
        const baseLat = terrainData[0][0][0]; // 基準の緯度
        const baseLon = terrainData[0][0][1]; // 基準の経度
        const baseElev = terrainData[0][0][2]; // 基準の標高

        // 地形メッシュの作成
        const terrainMesh = await generateTerrainMesh(
          terrainData,
          baseLat,
          baseLon,
          baseElev
        );
        scene.add(terrainMesh);

        // 道のメッシュを作成
        const elevations = await loadJson("elevation.json");
        const coordinates = await loadJson("geometry.json");
        const { roadMeth, verticalLineMeth } = generateRoadMesh(
          elevations,
          coordinates,
          baseLat,
          baseLon,
          baseElev
        );
        scene.add(roadMeth);
        scene.add(verticalLineMeth);

        // 光源の追加
        const { directionalLight, directionalLightHelper, shadowCameraHelper } =
          generateDirectionalLight();
        scene.add(directionalLight);
        scene.add(directionalLightHelper);
        scene.add(shadowCameraHelper);

        // レンダリングの設定
        function animate() {
          requestAnimationFrame(animate);
          cameraControls.update(); // OrbitControlsを更新
          renderer.render(scene, camera);
        }
        animate();

        // ウィンドウのリサイズに対応
        window.addEventListener("resize", () => {
          renderer.setSize(window.innerWidth, window.innerHeight);
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        });
      };
      main();
    </script>
  </body>
</html>
